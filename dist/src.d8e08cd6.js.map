{"version":3,"sources":["src/classes.ts","src/createInitialBoard.ts","src/renderBoard.ts","src/beginGameLoop.ts","src/index.ts"],"names":[],"mappings":"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","file":"src.d8e08cd6.js","sourceRoot":"..","sourcesContent":["export class Cell {\n  contents: Array<Lion | Zebra | Plant | Water | Dirt>;\n  isObstacle: boolean;\n  x: number;\n  y: number;\n\n  constructor({ x, y, contents }) {\n    this.contents = contents;\n    this.isObstacle = contents.some((content) => content.isObstacle);\n    this.x = x;\n    this.y = y;\n  }\n\n  updateContents(contents: Cell[\"contents\"]) {\n    this.contents = contents;\n  }\n\n  getNearestCellIndexes() {\n    return [\n      [this.x - 1, this.y],\n      [this.x + 1, this.y],\n      [this.x, this.y - 1],\n      [this.x, this.y + 1],\n    ];\n  }\n}\n\nexport class Animal {\n  age: \"newborn\" | \"child\" | \"adult\" | \"senior\";\n  // hunger and thirst are numbers between 0 - 10. If 10, animal loses health\n  hungerLevel: number;\n  thirstLevel: number;\n  // reproductive urge is a number between 0 - 10\n  reproductiveUrge: number;\n  speed: number;\n  // health is a number between 0 - 10 if 0 animal dies\n  health: number;\n  // All animals are obstacles\n  isObstacle: true;\n  // If false, animal is alive\n  deceased: boolean;\n\n  constructor() {\n    this.speed = 1;\n    this.age = \"adult\";\n    this.health = 10;\n    this.thirstLevel = 0;\n    this.hungerLevel = 0;\n    this.reproductiveUrge = 0;\n    this.isObstacle = true;\n    this.deceased = false;\n  }\n\n  getGreatestDesire() {\n    const wantsToReproduce =\n      this.reproductiveUrge > this.thirstLevel &&\n      this.reproductiveUrge > this.hungerLevel &&\n      this.hungerLevel <= 5 &&\n      this.thirstLevel <= 5;\n\n    const wantsToEat =\n      this.hungerLevel !== 0 && this.hungerLevel > this.thirstLevel;\n\n    const wantsToDrink =\n      this.thirstLevel !== 0 && this.thirstLevel >= this.hungerLevel;\n\n    if (wantsToReproduce) {\n      return \"looking for mate\";\n    } else if (wantsToEat) {\n      return \"looking for food\";\n    } else if (wantsToDrink) {\n      return \"looking for water\";\n    }\n  }\n\n  increaseDesires() {\n    this.hungerLevel++;\n    this.thirstLevel++;\n    this.reproductiveUrge++;\n  }\n\n  eat() {\n    // could update this method to take in a food source with varying nutritionalValue\n    if (this.health < 10) {\n      this.health++;\n    }\n    if (this.hungerLevel > 0) {\n      this.hungerLevel = this.hungerLevel - 3;\n    }\n  }\n\n  loseHealth(healthToLose: number) {\n    this.health = this.health - healthToLose;\n    if (this.health <= 0) {\n      this.deceased = true;\n    }\n  }\n}\n\nexport class Lion extends Animal {\n  type = \"lion\";\n  icon = \"ü¶Å\";\n}\n\nexport class Zebra extends Animal {\n  type = \"zebra\";\n  icon = \"ü¶ì\";\n}\n\nexport class Plant {\n  type: \"tree\" | \"grass\";\n  nutritionalValue: number;\n  // trees are obstacles, grass is not\n  isObstacle: boolean;\n\n  constructor(type: Plant[\"type\"]) {\n    this.type = type;\n    this.nutritionalValue = 50;\n    this.isObstacle = type === \"tree\";\n  }\n}\n\nexport class Dirt {\n  type = \"dirt\";\n  isObstacle = false;\n  // Whether or not the dirt should spawn a plant next iteration\n  willBecomePlant: boolean;\n\n  constructor() {\n    this.willBecomePlant = false;\n  }\n\n  turnIntoPlant() {\n    this.willBecomePlant = true;\n  }\n}\n\nexport class Water {\n  type = \"water\";\n  amount = Infinity;\n  isObstacle = true;\n}\n","import { Zebra, Lion, Cell, Dirt, Plant, Water } from \"./classes\";\n\ninterface IPopulateBoardParams {\n  boardState: Cell[][];\n  boardSize: number;\n  elementCount: number;\n  elementType: \"tree\" | \"grass\" | \"water\" | \"lion\" | \"zebra\";\n}\n\nfunction populateBoard({\n  boardState,\n  boardSize,\n  elementCount,\n  elementType,\n}: IPopulateBoardParams) {\n  console.log(\"Populating board with \" + elementCount + \" \" + elementType);\n  for (\n    let elementsCreated = 0;\n    elementsCreated < elementCount;\n    elementsCreated++\n  ) {\n    const randomCellX = chance.integer({ min: 0, max: boardSize - 1 });\n    const randomCellY = chance.integer({ min: 0, max: boardSize - 1 });\n    const randomCellContents = boardState[randomCellX][randomCellY].contents;\n    const cellContainsOnlyDirt = randomCellContents.length === 1;\n\n    if (cellContainsOnlyDirt) {\n      switch (elementType) {\n        case \"lion\":\n          randomCellContents.push(new Lion());\n          break;\n        case \"zebra\":\n          randomCellContents.push(new Zebra());\n          break;\n        case \"tree\":\n          randomCellContents.push(new Plant(\"tree\"));\n          break;\n        case \"grass\":\n          randomCellContents.push(new Plant(\"grass\"));\n          break;\n        case \"water\":\n          // first remove the dirt to replace it with water\n          randomCellContents.pop();\n          randomCellContents.push(new Water());\n      }\n    }\n  }\n}\n\ninterface ICreateInitialBoardParams {\n  boardSize?: number;\n  lionCount?: number;\n  zebraCount?: number;\n  treeCount?: number;\n  resourceDensity?: \"low\" | \"medium\" | \"high\";\n}\n\n// Initialize the board with dirt, then populate it with plants, animals and water\nexport function createInitialBoard({\n  boardSize = 20,\n  resourceDensity = \"low\",\n  treeCount = 1,\n  zebraCount = 1,\n  lionCount = 1,\n}: ICreateInitialBoardParams) {\n  // Throw error if user tries to create too many elements.\n  if (treeCount + zebraCount + lionCount > boardSize * boardSize) {\n    throw new RangeError(\n      \"Number of animals and plants exceeds bopard size! Please increase board size or lower number of animals and plants.\"\n    );\n  }\n  // Create a 2D array of cells that represents the board\n  const boardState: Cell[][] = [];\n\n  // Loop over each row in the board\n  for (let rowNumber = 0; rowNumber < boardSize; rowNumber++) {\n    const newRow: Cell[] = [];\n    // Loop over each column in the row and initialize each cell to just contain dirt\n    for (let columnNumber = 0; columnNumber < boardSize; columnNumber++) {\n      const ground = new Dirt();\n      const contents = [ground];\n\n      const cell = new Cell({ x: rowNumber, y: columnNumber, contents });\n\n      newRow.push(cell);\n    }\n    boardState.push(newRow);\n  }\n  // Now that every cell contains dirt, randomly insert plants, animals and water\n  const grassAndWaterCount =\n    resourceDensity === \"high\"\n      ? Math.round(boardSize / 2)\n      : resourceDensity === \"medium\"\n      ? Math.round(boardSize / 4)\n      : Math.round(boardSize / 6);\n  const elementsToCreate = [\n    { type: \"tree\" as const, count: treeCount },\n    { type: \"zebra\" as const, count: zebraCount },\n    { type: \"lion\" as const, count: lionCount },\n    { type: \"grass\" as const, count: grassAndWaterCount },\n    { type: \"water\" as const, count: grassAndWaterCount },\n  ];\n\n  elementsToCreate.forEach((element) => {\n    populateBoard({\n      boardState,\n      boardSize,\n      elementType: element.type,\n      elementCount: element.count,\n    });\n  });\n\n  return boardState;\n}\n","import { Cell } from \"./classes\";\n\ninterface IRenderBoardParams {\n  board: HTMLDivElement;\n  boardState: Cell[][];\n}\n\nexport function renderBoard({ board, boardState }: IRenderBoardParams) {\n  console.log(\"Rendering Board State: \", boardState);\n  // Clear the board so we don't end up creating new boards every iteration\n  // NAIVE and SLOW approach since we tear down every div and rebuild from scratch\n  board.innerHTML = \"\";\n  // Loop through every row\n  boardState.forEach((row) => {\n    // Create an HTML Div element to hold each cell in an individual row\n    const gridRow = document.createElement(\"div\");\n    gridRow.className = \"row\";\n    board.appendChild(gridRow);\n\n    // Loop through every cell in the current row\n    row.forEach((cell) => {\n      // Create an HTML Div element reprensenting each cell and it's contents\n      const gridCell = document.createElement(\"div\");\n      gridCell.classList.add(\"cell\");\n\n      cell.contents.forEach((content) => {\n        switch (content.type) {\n          case \"grass\":\n            gridCell.innerHTML = \"üå±\";\n            break;\n          case \"tree\":\n            gridCell.innerHTML = \"üå≥\";\n            break;\n          case \"water\":\n            gridCell.classList.add(\"water\");\n            break;\n          case \"lion\":\n            gridCell.innerHTML = \"ü¶Å\";\n            break;\n          case \"zebra\":\n            gridCell.innerHTML = \"ü¶ì\";\n            break;\n          // Dirt is the default\n          default:\n            gridCell.classList.add(\"dirt\");\n        }\n      });\n      gridRow.appendChild(gridCell);\n    });\n  });\n}\n","import { Cell, Animal, Plant, Water, Dirt } from \"./classes\";\r\nimport { renderBoard } from \"./renderBoard\";\r\n\r\n// function created by chatgpt and updated with a criteria function\r\nfunction findNearestCell(x, y, array, criteria) {\r\n  let minDistance = Number.MAX_VALUE;\r\n  let nearestElement = null;\r\n\r\n  for (let i = 0; i < array.length; i++) {\r\n    for (let j = 0; j < array[i].length; j++) {\r\n      if (array[i][j] && criteria(array[i][j])) {\r\n        // only check for elements matching criteria such as \"call contains water\"\r\n        const distance = Math.sqrt((i - x) ** 2 + (j - y) ** 2); // calculate Euclidean distance\r\n        if (distance < minDistance) {\r\n          minDistance = distance;\r\n          nearestElement = array[i][j];\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  return nearestElement;\r\n}\r\n\r\nfunction deepClone(arr) {\r\n  var len = arr.length;\r\n  var newArr = new Array(len);\r\n  for (var i = 0; i < len; i++) {\r\n    if (Array.isArray(arr[i])) {\r\n      newArr[i] = deepClone(arr[i]);\r\n    } else {\r\n      newArr[i] = arr[i];\r\n    }\r\n  }\r\n  return newArr;\r\n}\r\n\r\ninterface IBeginGameLoopParams {\r\n  initialBoardState: Cell[][];\r\n  board: HTMLDivElement;\r\n}\r\n\r\nexport function beginGameLoop({\r\n  initialBoardState,\r\n  board,\r\n}: IBeginGameLoopParams) {\r\n  const boardState = initialBoardState;\r\n  // The render method takes the board state and renders it to the board HTML\r\n  renderBoard({ boardState, board });\r\n  // -----------------------------------------------------\r\n  const gameLoop = setInterval(() => {\r\n    console.log(\"ROUND BEGINNING\");\r\n    const updatedBoardState = deepClone(boardState);\r\n\r\n    boardState.forEach((row) => {\r\n      row.forEach((cell) => {\r\n        const cellContainsSomething = cell.contents.length > 1;\r\n\r\n        if (cellContainsSomething) {\r\n          cell.contents.forEach((element) => {\r\n            if (element instanceof Animal) {\r\n              console.log(\"Calculating \" + element.type + \" Desires\");\r\n              // increase hunger, thirst and reproductive urge\r\n              element.increaseDesires();\r\n              // get animals greatest desire to determine what they should move towards\r\n              const desire = element.getGreatestDesire();\r\n              console.log(element.type + \"'s greatest desire: \" + desire);\r\n              switch (desire) {\r\n                case \"looking for water\":\r\n                  const nearestDesire = findNearestCell(\r\n                    cell.x,\r\n                    cell.y,\r\n                    boardState,\r\n                    (cell) => {\r\n                      return cell.contents.some(\r\n                        (element) => element instanceof Water\r\n                      );\r\n                    }\r\n                  );\r\n                  // Check if animal is already next to their greatest desire\r\n                  if (\r\n                    (Math.abs(nearestDesire.x - cell.x) === 1 ||\r\n                      nearestDesire.x === cell.x) &&\r\n                    (Math.abs(nearestDesire.y - cell.y) === 1 ||\r\n                      nearestDesire.y === cell.y)\r\n                  ) {\r\n                    break;\r\n                  }\r\n\r\n                  let newXValue =\r\n                    cell.x > nearestDesire.x\r\n                      ? cell.x - 1\r\n                      : cell.x < nearestDesire.x\r\n                      ? cell.x + 1\r\n                      : cell.x;\r\n                  let newYValue =\r\n                    cell.y > nearestDesire.y\r\n                      ? cell.y - 1\r\n                      : cell.y < nearestDesire.y\r\n                      ? cell.y + 1\r\n                      : cell.y;\r\n\r\n                  let availableCell = null;\r\n                  // Look for a non-obstacle cell that is adjacent to the current position of the moving animal\r\n                  const adjacentCells = [\r\n                    [cell.x - 1, cell.y],\r\n                    [cell.x + 1, cell.y],\r\n                    [cell.x, cell.y - 1],\r\n                    [cell.x, cell.y + 1],\r\n                    [cell.x + 1, cell.y + 1],\r\n                    [cell.x - 1, cell.y - 1],\r\n                    [cell.x + 1, cell.y - 1],\r\n                    [cell.x - 1, cell.y + 1],\r\n                  ];\r\n                  for (const [x, y] of adjacentCells) {\r\n                    if (\r\n                      x >= 0 &&\r\n                      x < boardState.length &&\r\n                      y >= 0 &&\r\n                      y < boardState[0].length &&\r\n                      !boardState[x][y].contents.some(\r\n                        (element) => element.isObstacle\r\n                      )\r\n                    ) {\r\n                      availableCell = updatedBoardState[x][y];\r\n                      break;\r\n                    }\r\n                  }\r\n                  // If no obstacle, move along the optimal path\r\n                  if (\r\n                    !boardState[newXValue][newYValue].contents.some(\r\n                      (element) => element.isObstacle\r\n                    )\r\n                  ) {\r\n                    const movingAnimal =\r\n                      updatedBoardState[cell.x][cell.y].contents.pop();\r\n                    updatedBoardState[newXValue][newYValue].contents.push(\r\n                      movingAnimal!\r\n                    );\r\n                    // if obstacle, choose the first available cell with no obstacle\r\n                  } else if (availableCell) {\r\n                    const movingAnimal =\r\n                      updatedBoardState[cell.x][cell.y].contents.pop();\r\n                    availableCell.contents.push(movingAnimal!);\r\n                  } else {\r\n                    // if no open spaces and no optimal path available, don't do anything.\r\n                    // No available non-obstacle cell adjacent to the current position of the moving animal\r\n                  }\r\n                  break;\r\n              }\r\n            }\r\n          });\r\n        }\r\n      });\r\n    });\r\n    // Now that we have updated the board state we need to re-render it!\r\n    renderBoard({ boardState: updatedBoardState, board });\r\n    // 1. check if animals should eat or drink\r\n    // 2. check if animals will die of thirst, hunger or predation\r\n    // 3. check if animals should reproduce\r\n    // 4. move animals toward their greatest need (food, water or reproduction)\r\n  }, 3000);\r\n\r\n  // ---------------------- CREATE GAME CONTROLS ----------------------\r\n  window.addEventListener(\"keyup\", (event) => {\r\n    if (event.key === \"Escape\") {\r\n      clearInterval(gameLoop);\r\n    }\r\n  });\r\n}\r\n","import { createInitialBoard } from \"./createInitialBoard\";\nimport { beginGameLoop } from \"./beginGameLoop\";\nimport \"./styles.css\";\n\n// The board is the actual HTML we want to render. Not to be mistaken for the board state which is Cell[][]\nconst board = document.getElementById(\"board\") as HTMLDivElement;\n\ntry {\n  // The board state is the JavaScript object representing each cell and it's contents.\n  const initialBoardState = createInitialBoard({\n    boardSize: 15,\n    lionCount: 3,\n    zebraCount: 5,\n    resourceDensity: \"low\",\n  });\n  beginGameLoop({ initialBoardState, board });\n} catch (error) {\n  alert(error);\n}\n"]}